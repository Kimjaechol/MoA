/**
 * AI-Powered PPTX Presentation Generator
 *
 * Two-tier approach:
 *   1. Smart extraction (client-side): Analyzes HTML structure, extracts
 *      headings/paragraphs/tables/images, and creates structured slides.
 *   2. AI summarization (via /api/slides/generate): Sends content to LLM
 *      for intelligent summarization with story flow and keywords.
 *
 * Uses PptxGenJS for rendering professional PPTX files.
 */

// Dynamic import to avoid Node.js module issues in webpack client bundle
type PptxGenJSType = import("pptxgenjs").default;

// ─── Types ──────────────────────────────────────────

export interface SlideData {
  /** Slide type for layout selection */
  type: "title" | "content" | "section" | "two-column" | "image" | "table" | "summary";
  /** Slide title */
  title: string;
  /** Subtitle or section label */
  subtitle?: string;
  /** Bullet points or key text */
  bullets?: string[];
  /** Left column bullets (for two-column layout) */
  leftBullets?: string[];
  /** Right column bullets (for two-column layout) */
  rightBullets?: string[];
  /** Image URL or base64 */
  imageUrl?: string;
  /** Image caption */
  imageCaption?: string;
  /** Table data: rows of cells */
  tableData?: string[][];
  /** Speaker notes */
  notes?: string;
}

export interface PptxOptions {
  /** Presentation title */
  title: string;
  /** Author name */
  author?: string;
  /** Theme color scheme */
  theme?: "blue" | "dark" | "green" | "red" | "purple";
  /** Max slides to generate */
  maxSlides?: number;
  /** Use AI summarization API (if available) */
  useAi?: boolean;
}

// ─── Theme Configuration ────────────────────────────

interface ThemeColors {
  primary: string;
  secondary: string;
  accent: string;
  bgDark: string;
  bgLight: string;
  textDark: string;
  textLight: string;
  bulletColor: string;
}

const THEMES: Record<string, ThemeColors> = {
  blue: {
    primary: "667eea",
    secondary: "764ba2",
    accent: "4fc3f7",
    bgDark: "1a1a3e",
    bgLight: "f0f4ff",
    textDark: "222222",
    textLight: "ffffff",
    bulletColor: "667eea",
  },
  dark: {
    primary: "bb86fc",
    secondary: "03dac6",
    accent: "cf6679",
    bgDark: "121212",
    bgLight: "1e1e2e",
    textDark: "e0e0e0",
    textLight: "ffffff",
    bulletColor: "bb86fc",
  },
  green: {
    primary: "4caf50",
    secondary: "81c784",
    accent: "00e676",
    bgDark: "1b3a1b",
    bgLight: "e8f5e9",
    textDark: "222222",
    textLight: "ffffff",
    bulletColor: "4caf50",
  },
  red: {
    primary: "e53935",
    secondary: "ef5350",
    accent: "ff5252",
    bgDark: "3e1a1a",
    bgLight: "ffebee",
    textDark: "222222",
    textLight: "ffffff",
    bulletColor: "e53935",
  },
  purple: {
    primary: "9c27b0",
    secondary: "ba68c8",
    accent: "ea80fc",
    bgDark: "2e1a3e",
    bgLight: "f3e5f5",
    textDark: "222222",
    textLight: "ffffff",
    bulletColor: "9c27b0",
  },
};

// ─── Smart Content Extraction ───────────────────────

/**
 * Analyze HTML content and extract structured slide data.
 * This is the client-side "smart extraction" mode that doesn't need an LLM.
 */
export function extractSlidesFromHtml(html: string, options: PptxOptions): SlideData[] {
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, "text/html");
  const body = doc.body;
  const maxSlides = options.maxSlides ?? 15;
  const slides: SlideData[] = [];

  // 1. Title slide
  slides.push({
    type: "title",
    title: options.title,
    subtitle: extractFirstParagraph(body),
    notes: "Generated by MoA Document Editor",
  });

  // 2. Scan content sections (grouped by headings)
  const sections = groupByHeadings(body);

  for (const section of sections) {
    if (slides.length >= maxSlides) break;

    // Section header slide for H1/H2
    if (section.level <= 2 && section.title) {
      slides.push({
        type: "section",
        title: section.title,
        subtitle: section.summary,
        notes: section.fullText.slice(0, 300),
      });
    }

    // Content slides for each section
    if (section.bullets.length > 0) {
      if (slides.length >= maxSlides) break;

      // Split long bullet lists across multiple slides
      const chunked = chunkArray(section.bullets, 5);
      for (const chunk of chunked) {
        if (slides.length >= maxSlides) break;
        slides.push({
          type: "content",
          title: section.title || options.title,
          bullets: chunk.map(trimToKeywords),
          notes: chunk.join("\n"),
        });
      }
    }

    // Table slides
    if (section.tables.length > 0) {
      for (const table of section.tables) {
        if (slides.length >= maxSlides) break;
        slides.push({
          type: "table",
          title: section.title || "Data",
          tableData: table.slice(0, 8), // max 8 rows per slide
          notes: `Table with ${table.length} rows`,
        });
      }
    }

    // Image slides
    if (section.images.length > 0) {
      for (const img of section.images) {
        if (slides.length >= maxSlides) break;
        slides.push({
          type: "image",
          title: section.title || "",
          imageUrl: img.src,
          imageCaption: img.alt || "",
        });
      }
    }
  }

  // 3. Summary slide
  if (slides.length > 2) {
    const keyPoints = sections
      .filter((s) => s.title)
      .map((s) => s.title)
      .slice(0, 6);

    if (keyPoints.length > 0) {
      slides.push({
        type: "summary",
        title: "Summary",
        subtitle: options.title,
        bullets: keyPoints,
      });
    }
  }

  return slides;
}

// ─── PPTX Rendering with PptxGenJS ─────────────────

/**
 * Render SlideData array into a PPTX file and trigger download.
 */
export async function renderPptx(slides: SlideData[], options: PptxOptions): Promise<void> {
  // Dynamic import for browser-only usage (avoids Node.js module bundling)
  const PptxGenJS = (await import("pptxgenjs")).default;
  const pptx: PptxGenJSType = new PptxGenJS();
  const theme = THEMES[options.theme ?? "blue"];

  // Document properties
  pptx.author = options.author ?? "MoA Document Editor";
  pptx.title = options.title;
  pptx.subject = "AI-Generated Presentation";
  pptx.layout = "LAYOUT_WIDE"; // 16:9

  // Define slide masters
  defineSlideMasters(pptx, theme);

  // Render each slide
  for (const slideData of slides) {
    switch (slideData.type) {
      case "title":
        renderTitleSlide(pptx, slideData, theme);
        break;
      case "section":
        renderSectionSlide(pptx, slideData, theme);
        break;
      case "content":
        renderContentSlide(pptx, slideData, theme);
        break;
      case "two-column":
        renderTwoColumnSlide(pptx, slideData, theme);
        break;
      case "table":
        renderTableSlide(pptx, slideData, theme);
        break;
      case "image":
        renderImageSlide(pptx, slideData, theme);
        break;
      case "summary":
        renderSummarySlide(pptx, slideData, theme);
        break;
    }
  }

  // Export and download
  await pptx.writeFile({ fileName: `${options.title}.pptx` });
}

/**
 * Main export function: extract slides from HTML and generate PPTX.
 */
export async function exportAsPptx(html: string, options: PptxOptions): Promise<void> {
  let slides: SlideData[];

  if (options.useAi) {
    // Try AI-powered summarization via API
    try {
      slides = await fetchAiSlides(html, options);
    } catch {
      // Fallback to smart extraction
      slides = extractSlidesFromHtml(html, options);
    }
  } else {
    slides = extractSlidesFromHtml(html, options);
  }

  await renderPptx(slides, options);
}

// ─── AI Summarization API ───────────────────────────

/**
 * Call the server-side AI endpoint for intelligent slide generation.
 */
async function fetchAiSlides(html: string, options: PptxOptions): Promise<SlideData[]> {
  const res = await fetch("/api/slides/generate", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      html,
      title: options.title,
      maxSlides: options.maxSlides ?? 15,
      theme: options.theme ?? "blue",
    }),
  });

  if (!res.ok) {
    throw new Error(`AI slide generation failed: ${res.status}`);
  }

  const data = await res.json();
  return data.slides as SlideData[];
}

// ─── Slide Master Definitions ───────────────────────

function defineSlideMasters(pptx: PptxGenJSType, theme: ThemeColors) {
  // Title Master — background.fill is a plain color string in PptxGenJS v4
  pptx.defineSlideMaster({
    title: "TITLE_MASTER",
    background: { fill: theme.bgDark },
  });

  // Content Master
  pptx.defineSlideMaster({
    title: "CONTENT_MASTER",
    background: { fill: "FFFFFF" },
    objects: [
      // Top accent bar
      {
        rect: {
          x: 0,
          y: 0,
          w: "100%",
          h: 0.06,
          fill: { color: theme.primary },
        },
      },
      // Bottom bar with page number
      {
        rect: {
          x: 0,
          y: 5.2,
          w: "100%",
          h: 0.3,
          fill: { color: theme.bgLight },
        },
      },
    ],
    slideNumber: {
      x: 12.0,
      y: 5.2,
      fontSize: 9,
      color: "888888",
    },
  });

  // Section Master
  pptx.defineSlideMaster({
    title: "SECTION_MASTER",
    background: { fill: theme.primary },
  });
}

// ─── Slide Renderers ────────────────────────────────

function renderTitleSlide(pptx: PptxGenJSType, data: SlideData, theme: ThemeColors) {
  const slide = pptx.addSlide({ masterName: "TITLE_MASTER" });

  // Gradient-like background with overlay shape
  slide.addShape(pptx.ShapeType.rect, {
    x: 0,
    y: 0,
    w: "100%",
    h: "100%",
    fill: { color: theme.bgDark },
  });

  // Accent line
  slide.addShape(pptx.ShapeType.rect, {
    x: 1.5,
    y: 2.3,
    w: 2.0,
    h: 0.06,
    fill: { color: theme.accent },
  });

  // Title
  slide.addText(data.title, {
    x: 1.5,
    y: 2.5,
    w: 10,
    h: 1.2,
    fontSize: 36,
    fontFace: "Malgun Gothic",
    color: theme.textLight,
    bold: true,
    align: "left",
  });

  // Subtitle
  if (data.subtitle) {
    slide.addText(data.subtitle, {
      x: 1.5,
      y: 3.7,
      w: 9,
      h: 0.8,
      fontSize: 16,
      fontFace: "Malgun Gothic",
      color: theme.accent,
      align: "left",
    });
  }

  // Footer
  slide.addText("MoA Document Editor", {
    x: 1.5,
    y: 4.8,
    w: 5,
    h: 0.4,
    fontSize: 10,
    color: "666666",
    fontFace: "Malgun Gothic",
  });

  if (data.notes) slide.addNotes(data.notes);
}

function renderSectionSlide(pptx: PptxGenJSType, data: SlideData, theme: ThemeColors) {
  const slide = pptx.addSlide({ masterName: "SECTION_MASTER" });

  // Section title
  slide.addText(data.title, {
    x: 1.5,
    y: 1.8,
    w: 10,
    h: 1.5,
    fontSize: 32,
    fontFace: "Malgun Gothic",
    color: theme.textLight,
    bold: true,
    align: "left",
  });

  // Divider
  slide.addShape(pptx.ShapeType.rect, {
    x: 1.5,
    y: 3.3,
    w: 3.0,
    h: 0.04,
    fill: { color: theme.textLight },
  });

  // Subtitle
  if (data.subtitle) {
    slide.addText(data.subtitle, {
      x: 1.5,
      y: 3.6,
      w: 9,
      h: 0.8,
      fontSize: 16,
      fontFace: "Malgun Gothic",
      color: theme.textLight,
      italic: true,
    });
  }

  if (data.notes) slide.addNotes(data.notes);
}

function renderContentSlide(pptx: PptxGenJSType, data: SlideData, theme: ThemeColors) {
  const slide = pptx.addSlide({ masterName: "CONTENT_MASTER" });

  // Title
  slide.addText(data.title, {
    x: 0.7,
    y: 0.3,
    w: 11.5,
    h: 0.8,
    fontSize: 24,
    fontFace: "Malgun Gothic",
    color: theme.primary,
    bold: true,
  });

  // Bullets
  if (data.bullets && data.bullets.length > 0) {
    const textRows = data.bullets.map((bullet) => ({
      text: bullet,
      options: {
        fontSize: 16,
        fontFace: "Malgun Gothic" as const,
        color: theme.textDark,
        bullet: {
          type: "bullet" as const,
          code: "25CF",
          color: theme.bulletColor,
        },
        lineSpacingMultiple: 1.5,
        paraSpaceBefore: 6,
      },
    }));

    slide.addText(textRows, {
      x: 1.0,
      y: 1.3,
      w: 10.5,
      h: 3.5,
      valign: "top",
    });
  }

  if (data.notes) slide.addNotes(data.notes);
}

function renderTwoColumnSlide(pptx: PptxGenJSType, data: SlideData, theme: ThemeColors) {
  const slide = pptx.addSlide({ masterName: "CONTENT_MASTER" });

  // Title
  slide.addText(data.title, {
    x: 0.7,
    y: 0.3,
    w: 11.5,
    h: 0.8,
    fontSize: 24,
    fontFace: "Malgun Gothic",
    color: theme.primary,
    bold: true,
  });

  // Left column
  if (data.leftBullets) {
    const leftRows = data.leftBullets.map((b) => ({
      text: b,
      options: {
        fontSize: 14,
        fontFace: "Malgun Gothic" as const,
        color: theme.textDark,
        bullet: { type: "bullet" as const, code: "25CF", color: theme.bulletColor },
        lineSpacingMultiple: 1.4,
      },
    }));

    slide.addText(leftRows, {
      x: 0.7,
      y: 1.3,
      w: 5.5,
      h: 3.5,
      valign: "top",
    });
  }

  // Divider line
  slide.addShape(pptx.ShapeType.line, {
    x: 6.4,
    y: 1.3,
    w: 0,
    h: 3.5,
    line: { color: "CCCCCC", width: 1 },
  });

  // Right column
  if (data.rightBullets) {
    const rightRows = data.rightBullets.map((b) => ({
      text: b,
      options: {
        fontSize: 14,
        fontFace: "Malgun Gothic" as const,
        color: theme.textDark,
        bullet: { type: "bullet" as const, code: "25CF", color: theme.bulletColor },
        lineSpacingMultiple: 1.4,
      },
    }));

    slide.addText(rightRows, {
      x: 6.8,
      y: 1.3,
      w: 5.5,
      h: 3.5,
      valign: "top",
    });
  }

  if (data.notes) slide.addNotes(data.notes);
}

function renderTableSlide(pptx: PptxGenJSType, data: SlideData, theme: ThemeColors) {
  const slide = pptx.addSlide({ masterName: "CONTENT_MASTER" });

  // Title
  slide.addText(data.title, {
    x: 0.7,
    y: 0.3,
    w: 11.5,
    h: 0.8,
    fontSize: 24,
    fontFace: "Malgun Gothic",
    color: theme.primary,
    bold: true,
  });

  if (data.tableData && data.tableData.length > 0) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const rows: any[][] = data.tableData.map((row, rowIdx) =>
      row.map((cell) => ({
        text: cell,
        options: {
          fontSize: 11,
          fontFace: "Malgun Gothic",
          color: rowIdx === 0 ? theme.textLight : theme.textDark,
          bold: rowIdx === 0,
          fill: { color: rowIdx === 0 ? theme.primary : rowIdx % 2 === 0 ? "F5F5F5" : "FFFFFF" },
          border: [
            { type: "solid" as const, pt: 0.5, color: "DDDDDD" },
            { type: "solid" as const, pt: 0.5, color: "DDDDDD" },
            { type: "solid" as const, pt: 0.5, color: "DDDDDD" },
            { type: "solid" as const, pt: 0.5, color: "DDDDDD" },
          ],
          valign: "middle" as const,
          align: "left" as const,
        },
      })),
    );

    slide.addTable(rows, {
      x: 0.7,
      y: 1.3,
      w: 11.5,
      colW: Array(data.tableData[0].length).fill(11.5 / data.tableData[0].length),
      autoPage: false,
    });
  }

  if (data.notes) slide.addNotes(data.notes);
}

function renderImageSlide(pptx: PptxGenJSType, data: SlideData, theme: ThemeColors) {
  const slide = pptx.addSlide({ masterName: "CONTENT_MASTER" });

  // Title
  if (data.title) {
    slide.addText(data.title, {
      x: 0.7,
      y: 0.3,
      w: 11.5,
      h: 0.8,
      fontSize: 24,
      fontFace: "Malgun Gothic",
      color: theme.primary,
      bold: true,
    });
  }

  // Image
  if (data.imageUrl) {
    try {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const imgOpts: any = {
        x: 2.0,
        y: 1.3,
        w: 9.0,
        h: 3.5,
        sizing: { type: "contain", w: 9.0, h: 3.5 },
      };

      if (data.imageUrl.startsWith("data:")) {
        imgOpts.data = data.imageUrl;
      } else {
        imgOpts.path = data.imageUrl;
      }

      slide.addImage(imgOpts);
    } catch {
      // If image fails, add placeholder text
      slide.addText("[Image]", {
        x: 2.0,
        y: 2.5,
        w: 9.0,
        h: 1.0,
        fontSize: 14,
        color: "999999",
        align: "center",
      });
    }
  }

  // Caption
  if (data.imageCaption) {
    slide.addText(data.imageCaption, {
      x: 2.0,
      y: 4.8,
      w: 9.0,
      h: 0.4,
      fontSize: 11,
      fontFace: "Malgun Gothic",
      color: "666666",
      align: "center",
      italic: true,
    });
  }
}

function renderSummarySlide(pptx: PptxGenJSType, data: SlideData, theme: ThemeColors) {
  const slide = pptx.addSlide({ masterName: "TITLE_MASTER" });

  // Background
  slide.addShape(pptx.ShapeType.rect, {
    x: 0,
    y: 0,
    w: "100%",
    h: "100%",
    fill: { color: theme.bgDark },
  });

  // "Summary" label
  slide.addText(data.title, {
    x: 1.5,
    y: 0.8,
    w: 10,
    h: 0.6,
    fontSize: 14,
    fontFace: "Malgun Gothic",
    color: theme.accent,
    bold: true,
    isTextBox: true,
  });

  // Subtitle (document title)
  if (data.subtitle) {
    slide.addText(data.subtitle, {
      x: 1.5,
      y: 1.3,
      w: 10,
      h: 0.8,
      fontSize: 28,
      fontFace: "Malgun Gothic",
      color: theme.textLight,
      bold: true,
    });
  }

  // Key points
  if (data.bullets && data.bullets.length > 0) {
    const rows = data.bullets.map((bullet, idx) => ({
      text: `${idx + 1}.  ${bullet}`,
      options: {
        fontSize: 16,
        fontFace: "Malgun Gothic" as const,
        color: theme.textLight,
        lineSpacingMultiple: 1.6,
        paraSpaceBefore: 4,
      },
    }));

    slide.addText(rows, {
      x: 1.5,
      y: 2.3,
      w: 10,
      h: 2.8,
      valign: "top" as const,
    });
  }

  // Thank you
  slide.addText("Thank you", {
    x: 1.5,
    y: 4.8,
    w: 5,
    h: 0.4,
    fontSize: 12,
    color: "666666",
    fontFace: "Malgun Gothic",
    italic: true,
  });
}

// ─── HTML Content Analysis Helpers ──────────────────

interface ContentSection {
  level: number;
  title: string;
  summary: string;
  fullText: string;
  bullets: string[];
  tables: string[][][];
  images: Array<{ src: string; alt: string }>;
}

function groupByHeadings(body: HTMLElement): ContentSection[] {
  const sections: ContentSection[] = [];
  let current: ContentSection | null = null;

  function flushSection() {
    if (current) {
      // Generate summary from full text
      if (!current.summary && current.fullText) {
        current.summary = current.fullText.slice(0, 100).trim();
        if (current.fullText.length > 100) current.summary += "...";
      }
      sections.push(current);
    }
  }

  for (const node of Array.from(body.childNodes)) {
    if (node.nodeType !== Node.ELEMENT_NODE) {
      if (node.nodeType === Node.TEXT_NODE && node.textContent?.trim()) {
        if (!current) {
          current = createEmptySection(0, "");
        }
        current.fullText += (node.textContent?.trim() ?? "") + " ";
        current.bullets.push(node.textContent.trim());
      }
      continue;
    }

    const el = node as HTMLElement;
    const tag = el.tagName.toLowerCase();

    // Heading → new section
    const headingMatch = tag.match(/^h([1-6])$/);
    if (headingMatch) {
      flushSection();
      const level = parseInt(headingMatch[1], 10);
      current = createEmptySection(level, el.textContent?.trim() ?? "");
      continue;
    }

    // Ensure we have a section
    if (!current) {
      current = createEmptySection(0, "");
    }

    // Table
    if (tag === "table") {
      const tableData = extractTableData(el);
      if (tableData.length > 0) current.tables.push(tableData);
      continue;
    }

    // Image
    if (tag === "img") {
      const src = el.getAttribute("src") ?? "";
      const alt = el.getAttribute("alt") ?? "";
      if (src) current.images.push({ src, alt });
      continue;
    }

    // Check for images inside element
    const imgs = el.querySelectorAll("img");
    for (const img of Array.from(imgs)) {
      const src = img.getAttribute("src") ?? "";
      const alt = img.getAttribute("alt") ?? "";
      if (src) current.images.push({ src, alt });
    }

    // Lists
    if (tag === "ul" || tag === "ol") {
      const items = el.querySelectorAll("li");
      for (const li of Array.from(items)) {
        const text = li.textContent?.trim() ?? "";
        if (text) {
          current.bullets.push(text);
          current.fullText += text + " ";
        }
      }
      continue;
    }

    // Paragraph / div / blockquote / other block elements
    const text = el.textContent?.trim() ?? "";
    if (text) {
      current.fullText += text + " ";
      // Split long paragraphs into sentences for bullet points
      if (text.length > 100) {
        const sentences = splitSentences(text);
        current.bullets.push(...sentences.slice(0, 3));
      } else if (text.length > 10) {
        current.bullets.push(text);
      }
    }
  }

  flushSection();
  return sections;
}

function createEmptySection(level: number, title: string): ContentSection {
  return {
    level,
    title,
    summary: "",
    fullText: "",
    bullets: [],
    tables: [],
    images: [],
  };
}

function extractTableData(tableEl: HTMLElement): string[][] {
  const rows: string[][] = [];
  const trEls = tableEl.querySelectorAll("tr");
  for (const tr of Array.from(trEls)) {
    const cells: string[] = [];
    tr.querySelectorAll("td, th").forEach((cell) => {
      cells.push(cell.textContent?.trim() ?? "");
    });
    if (cells.length > 0) rows.push(cells);
  }
  return rows;
}

function extractFirstParagraph(body: HTMLElement): string {
  const p = body.querySelector("p");
  if (p) {
    const text = p.textContent?.trim() ?? "";
    if (text.length > 120) return text.slice(0, 120) + "...";
    return text;
  }
  return "";
}

/**
 * Trim text to keyword-focused summary for slide bullets.
 * Keeps sentences short and impactful.
 */
function trimToKeywords(text: string): string {
  // Remove excessive whitespace
  let trimmed = text.replace(/\s+/g, " ").trim();

  // If already short, keep as is
  if (trimmed.length <= 80) return trimmed;

  // Try to cut at sentence boundary
  const sentenceEnd = trimmed.indexOf(".", 40);
  if (sentenceEnd > 0 && sentenceEnd < 100) {
    return trimmed.slice(0, sentenceEnd + 1);
  }

  // Cut at word boundary
  const cutPoint = trimmed.lastIndexOf(" ", 80);
  if (cutPoint > 30) {
    return trimmed.slice(0, cutPoint) + "...";
  }

  return trimmed.slice(0, 80) + "...";
}

function splitSentences(text: string): string[] {
  // Split on Korean/English sentence endings
  return text
    .split(/(?<=[.!?。])\s+/)
    .map((s) => s.trim())
    .filter((s) => s.length > 5);
}

function chunkArray<T>(arr: T[], size: number): T[][] {
  const chunks: T[][] = [];
  for (let i = 0; i < arr.length; i += size) {
    chunks.push(arr.slice(i, i + size));
  }
  return chunks;
}
